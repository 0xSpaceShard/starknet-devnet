"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8749],{8945:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var i=t(4848),o=t(8453);const s={},c="Blocks",a={id:"blocks",title:"Blocks",description:"State commitment",source:"@site/versioned_docs/version-0.6.1/blocks.md",sourceDirName:".",slug:"/blocks",permalink:"/starknet-devnet/docs/blocks",draft:!1,unlisted:!1,editUrl:"https://github.com/0xSpaceShard/starknet-devnet/blob/master/website/versioned_docs/version-0.6.1/blocks.md",tags:[],version:"0.6.1",frontMatter:{},sidebar:"docSidebar",previous:{title:"Account balance",permalink:"/starknet-devnet/docs/balance"},next:{title:"Dump, load, restart",permalink:"/starknet-devnet/docs/dump-load-restart"}},r={},l=[{value:"State commitment",id:"state-commitment",level:2},{value:"Genesis block",id:"genesis-block",level:2},{value:"Limits",id:"limits",level:2},{value:"Creating blocks on transaction",id:"creating-blocks-on-transaction",level:2},{value:"Creating blocks on demand",id:"creating-blocks-on-demand",level:2},{value:"Automatic periodic block creation",id:"automatic-periodic-block-creation",level:2},{value:"Request new block creation",id:"request-new-block-creation",level:2},{value:"Timestamp manipulation",id:"timestamp-manipulation",level:2},{value:"Block abortion",id:"block-abortion",level:2},{value:"Example",id:"example",level:3},{value:"Limitations",id:"limitations",level:3},{value:"Websocket subscription notifications",id:"websocket-subscription-notifications",level:3},{value:"Request and response",id:"request-and-response",level:3},{value:"Accepting blocks on L1",id:"accepting-blocks-on-l1",level:2},{value:"Example",id:"example-1",level:3},{value:"Request and response",id:"request-and-response-1",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"blocks",children:"Blocks"}),"\n",(0,i.jsx)(n.h2,{id:"state-commitment",children:"State commitment"}),"\n",(0,i.jsx)(n.p,{children:"Block states are not committed in a Merke-Patricia trie or a similar tree-like structure. Block roots are therefore set to 0."}),"\n",(0,i.jsx)(n.h2,{id:"genesis-block",children:"Genesis block"}),"\n",(0,i.jsxs)(n.p,{children:["By default, Devnet starts with a genesis block labelled with number zero. In ",(0,i.jsx)(n.a,{href:"./forking",children:"forking mode"}),", the genesis block number is equal to the forked block number plus one."]}),"\n",(0,i.jsx)(n.h2,{id:"limits",children:"Limits"}),"\n",(0,i.jsxs)(n.p,{children:["To read more about block limits, see ",(0,i.jsx)(n.a,{href:"./intro#limits",children:"this"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-blocks-on-transaction",children:"Creating blocks on transaction"}),"\n",(0,i.jsxs)(n.p,{children:["If you start Devnet with ",(0,i.jsx)(n.code,{children:"--block-generation-on transaction"}),", a new block is generated with each new transaction. This is the default block generation regime. This mode also supports ",(0,i.jsx)(n.a,{href:"#request-new-block-creation",children:"empty block creation"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-blocks-on-demand",children:"Creating blocks on demand"}),"\n",(0,i.jsxs)(n.p,{children:["If you start Devnet with the ",(0,i.jsx)(n.code,{children:"--block-generation-on demand"})," CLI option, you will enable the possibility to store more than one transaction in the pre-confirmed block (targetable via block tag ",(0,i.jsx)(n.code,{children:'"pre_confirmed"'}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["Once you've added the desired transactions into the pre-confirmed block, you can ",(0,i.jsx)(n.a,{href:"#request-new-block-creation",children:"request new block creation"}),". This will convert the pre-confirmed block to the latest block (targetable via block tag ",(0,i.jsx)(n.code,{children:'"latest"'}),"), giving it a block hash and a block number. All subsequent transactions will be stored in a new pre-confirmed block."]}),"\n",(0,i.jsx)(n.p,{children:"In case of demanding block creation with no pre-confirmed transactions, a new empty block will be generated."}),"\n",(0,i.jsx)(n.p,{children:"The creation of the genesis block is not affected by this feature."}),"\n",(0,i.jsxs)(n.p,{children:["The specifications of a block-creating request can be found ",(0,i.jsx)(n.a,{href:"#request-new-block-creation",children:"below"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"automatic-periodic-block-creation",children:"Automatic periodic block creation"}),"\n",(0,i.jsxs)(n.p,{children:["If started with the ",(0,i.jsx)(n.code,{children:"--block-generation-on <INTERVAL>"})," CLI option, Devnet will behave as in ",(0,i.jsxs)(n.a,{href:"#creating-blocks-on-demand",children:[(0,i.jsx)(n.code,{children:"demand"})," mode"]}),", but new blocks will be mined automatically every ",(0,i.jsx)(n.code,{children:"<INTERVAL>"})," seconds. Consider this example of spawning Devnet at moment ",(0,i.jsx)(n.code,{children:"t"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# t\n$ starknet-devnet --block-generation-on 10\n\n# t + 1s\n# user: send tx1\n\n# t + 4s\n# user: send tx2\n\n# t + 10s\n# Devnet: block automatically generated, contains tx1 and tx2\n\n# t + 12s\n# user: send tx3\n\n# t + 14s\n# user: invoke empty block creation\n# Devnet: generated block contains tx3\n\n# t + 20s\n# Devnet: block automatically generated, contains no txs (manual creation did not restart the counter)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"request-new-block-creation",children:"Request new block creation"}),"\n",(0,i.jsx)(n.p,{children:"To request the creation of a new block, send:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'JSON-RPC\n{\n    "jsonrpc": "2.0",\n    "id": "1",\n    "method": "devnet_createBlock"\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Result:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'{"block_hash": "0x115e1b390cafa7942b6ab141ab85040defe7dee9bef3bc31d8b5b3d01cc9c67"}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The newly created block will contain all pre-confirmed transactions, if any, since the last block creation."}),"\n",(0,i.jsx)(n.h2,{id:"timestamp-manipulation",children:"Timestamp manipulation"}),"\n",(0,i.jsxs)(n.p,{children:["To affect the timestamp of the newly created block, check out ",(0,i.jsx)(n.a,{href:"./starknet-time#set-time",children:"this page"})]}),"\n",(0,i.jsx)(n.h2,{id:"block-abortion",children:"Block abortion"}),"\n",(0,i.jsx)(n.p,{children:"This functionality allows simulating block abortion that can occur on mainnet as a consequence of e.g. block reorganization. Aborted blocks and their transactions are removed from Devnet's memory."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["Block abortion is only supported if Devnet is started in the ",(0,i.jsx)(n.code,{children:"--state-archive-capacity full"})," mode."]})}),"\n",(0,i.jsx)(n.p,{children:"You can abort blocks and revert transactions from the specified block to the currently latest block. Newly created blocks after the abortion will have accepted status and will continue with numbering where the last accepted block left off."}),"\n",(0,i.jsx)(n.p,{children:"The state of Devnet will be reverted to the state of the last accepted block."}),"\n",(0,i.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.p,{children:"Assume there are 3 accepted blocks numbered 1, 2 and 3. Upon receiving a request to abort blocks starting with block 2, the blocks numbered 2 and 3 are aborted and their transactions reverted. The state of network will be as it was in block 1. Once a new block is mined, it will be accepted and it will have number 2."}),"\n",(0,i.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,i.jsx)(n.p,{children:"Aborted blocks can only be queried by block hash. Devnet does not support the abortion of:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"blocks in the forking origin (i.e. blocks mined before the forked block)"}),"\n",(0,i.jsx)(n.li,{children:"already aborted blocks"}),"\n",(0,i.jsx)(n.li,{children:"Devnet's genesis block."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"websocket-subscription-notifications",children:"Websocket subscription notifications"}),"\n",(0,i.jsxs)(n.p,{children:["On block abortion, a ",(0,i.jsx)(n.code,{children:"starknet_subscriptionReorg"})," notification will be sent to all websocket subscribers requiring so according to ",(0,i.jsx)(n.a,{href:"https://github.com/starkware-libs/starknet-specs/blob/v0.8.0/api/starknet_ws_api.json#L236",children:"JSON-RPC websocket API specification"}),". The ",(0,i.jsx)(n.code,{children:"starting_block"})," of the orphaned chain is the successor of the new latest block and the ",(0,i.jsx)(n.code,{children:"ending_block"})," of the orphaned chain is the block that was latest before aborting. One reorg notification is sent per subscription, not per websocket, meaning that if a websocket has n subscriptions, it will receive n reorg notifications, each with its own subscription ID."]}),"\n",(0,i.jsxs)(n.p,{children:["If a socket has subscribed to transaction status changes of a transaction ",(0,i.jsx)(n.code,{children:"tx1"})," using ",(0,i.jsx)(n.code,{children:"starknet_subscribeTransactionStatus"})," and the block holding ",(0,i.jsx)(n.code,{children:"tx1"})," gets aborted, a ",(0,i.jsx)(n.code,{children:"starknet_subscriptionTransactionStatus"})," notification shall NOT be sent. The socket shall have to rely on handling ",(0,i.jsx)(n.code,{children:"starknet_subscriptionReorg"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"request-and-response",children:"Request and response"}),"\n",(0,i.jsx)(n.p,{children:"To abort, send:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'JSON-RPC\n{\n    "jsonrpc": "2.0",\n    "id": "1",\n    "method": "devnet_abortBlocks",\n    "params": {\n        "starting_block_id": BLOCK_ID\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Result:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'{\n    "aborted": [BLOCK_HASH_0, BLOCK_HASH_1, ...]\n}\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["When aborting the currently ",(0,i.jsx)(n.code,{children:"pre_confirmed"})," block, it is mined and aborted as latest."]})}),"\n",(0,i.jsx)(n.h2,{id:"accepting-blocks-on-l1",children:"Accepting blocks on L1"}),"\n",(0,i.jsxs)(n.p,{children:["This functionality allows simulating block acceptance on L1 (Ethereum). It merely marks the requested blocks and their transactions as ",(0,i.jsx)(n.code,{children:"ACCEPTED_ON_L1"}),". It is only supported on blocks that are ",(0,i.jsx)(n.code,{children:"ACCEPTED_ON_L2"})," and fails for all others, including blocks already ",(0,i.jsx)(n.code,{children:"ACCEPTED_ON_L1"}),". In case of ",(0,i.jsx)(n.a,{href:"./forking",children:"forking"}),", blocks on forking origin cannot be affected by this feature."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"This functionality does not actually perform actions on L1."})}),"\n",(0,i.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,i.jsxs)(n.p,{children:["Assume Devnet has mined blocks with numbers: 0 (origin), 1, 2 and 3. If this feature is invoked with ",(0,i.jsx)(n.code,{children:'starting_block_id={"block_number": 2}'}),", blocks 0, 1 and 2 shall be ",(0,i.jsx)(n.code,{children:"ACCEPTED_ON_L1"})," and block 3 shall remain ",(0,i.jsx)(n.code,{children:"ACCEPTED_ON_L2"}),". If after that another block (number 4) is mined, and this feature is invoked with ",(0,i.jsx)(n.code,{children:'starting_block_id="latest"'}),", blocks 0, 1, 2, 3 and 4 shall be ",(0,i.jsx)(n.code,{children:"ACCEPTED_ON_L1"}),". If a new block is mined after that (number 5), it shall be ",(0,i.jsx)(n.code,{children:"ACCEPTED_ON_L2"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"request-and-response-1",children:"Request and response"}),"\n",(0,i.jsx)(n.p,{children:"To accept a block and its transactions on L1, send:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'JSON-RPC\n{\n    "jsonrpc": "2.0",\n    "id": "1",\n    "method": "devnet_acceptOnL1",\n    "params": {\n        "starting_block_id": BLOCK_ID\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Result:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'{\n    "accepted": [BLOCK_HASH_0, BLOCK_HASH_1, ...]\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>a});var i=t(6540);const o={},s=i.createContext(o);function c(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);